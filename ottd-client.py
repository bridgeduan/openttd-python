import os, os.path
from ottd_lib import *
from irc_lib import *
from webserver import *
from ottd_config import *

class Event:
	msg=None	# the text
	type=None	# type (not used yet)
	source=None	# source (not used yet)
	parent=None	#the parent event
	self_sent=False
	broadcast=0	# publish to all or just to the parent event's owner?
	"""
		0 = all
		1 = private
		2 = team
	"""
	
	# distribution mask
	distribution = {
		'ingame':True,
		'chat':True,
		'log':True
	}

	def __repr__(self):
		return "Event<msg='%s', parent=%s, broadcast=%d, distribution='%s'>" % (
					self.msg,
					self.parent,
					self.broadcast,
					self.distribution
				)

class GameChatEvent(Event):
	"""
		this event is generated by ingame chat
	"""
	def __init__(self, msg, msg2, playerid, playername, parent=None, self_sent=False):
		self.msg = msg
		self.msg2 = msg2
		self.playerid = playerid
		self.playername = playername
		self.distribution = {
			'ingame':False,
			'chat':True,
			'log':True
		}		
		self.self_sent=self_sent
		
	def __name__(self):
		return "GameChatEvent"
	
	def __repr__(self):
		return "GameChatEvent<msg='%s', playerid=%d, playername='%s', self_sent=%d, broadcast=%d, distribution=%s>" % (
					self.msg,
					self.playerid,
					self.playername,
					self.self_sent,
					self.broadcast,
					self.distribution
				)

class IRCChatEvent(Event):
	"""
		this event is generated by IRC chat
	"""
	def __init__(self, msg, username, type):
		self.msg = msg
		self.username = username
		self.type = type
		self.distribution = {
			'ingame':True,
			'chat':False,
			'log':True
		}		

	
	def __name__(self):
		return "IRCChatEvent"

	def __repr__(self):
		return "IRCChatEvent<msg='%s', username=%s, broadcast=%d, distribution=%s>" % (
					self.msg,
					self.username,
					self.broadcast,
					self.distribution
				)

class BotEvent(Event):
	"""
		this event is generated by the bot itself
	"""
	def __init__(self, msg, parent=None):
		self.msg = msg
		self.parent = parent
		self.distribution = {
			'ingame':True,
			'chat':True,
			'log':True
		}		

	def __name__(self):
		return "BotEvent"
	
	def __repr__(self):
		return "BotEvent<msg='%s', broadcast=%d, distribution=%s, parent={{{%s}}}>" % (
					self.msg,
					self.broadcast,
					self.distribution,
					self.parent
				)

class SpectatorClient(Client):
	irc = None
	irc_server = config.get("irc", "server")
	irc_server_port = config.getint("irc", "serverport")
	irc_channel = config.get("irc", "channel")
	playerlist = {}
	webserver = None
	
	# this class implements the thread start method
	def run(self):
		pass
	
	def processEvent(self, event):
		# discard senseless events:
		if event.msg.strip() == '':
			return
	
		# debug event
		LOG.debug("got event: %s " % event)
	
		processLevel = 2
		# 2 = broadcast and process
		# 1 = broadcast
		# 0 = discard
		
		# process unique stuff for  each type
		if event.__name__() == "GameChatEvent":
			# discard events that we sent by ourself
			if event.self_sent == True:
				return
		elif event.__name__() == "IRCChatEvent":
			# dont accept commands by the bot itself
			if event.username == config.get("irc", "nickname"):
				processLevel = 0

		elif event.__name__() == "BotEvent":
			pass
		
		if processLevel == 0:
			return
				
		# process global stuff that is common for all events
		if not event.msg.startswith(config.get("main", "commandprefix")):
			processLevel = 1
	
		# distribute
		if event.broadcast == 0:
			# broadcast to all
			if event.distribution['ingame']:
				if event.__name__() == "IRCChatEvent" and event.username != '':
					self.sendChat("%s: %s" % (event.username, event.msg))
				else:
					self.sendChat(event.msg)
			if event.distribution['chat'] and self.irc and not self.irc is None:
				if event.__name__() == "GameChatEvent":
					self.irc.say(event.msg2, 0)
				else:
					self.irc.say(event.msg, 0)
		elif event.broadcast == 1:
			# todo: implement private chat for ingame teams
			pass
		elif event.broadcast == 2:
			# todo: implement private chat for ingame and private chat in IRC
			pass
		
		if event.distribution['log']:
			LOG.info("EVT| "+event.msg)

		# process
		if processLevel == 2:
			self.processCommand(event)

	def sendChat(self, msg):
		payload = packExt('bbHz', NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, msg)
		payload_size = len(payload)
		self.sendMsg(PACKET_CLIENT_CHAT, payload_size, payload, type=M_TCP)
		
	def sendTCPmsg(self, msg, payload):
		self.sendMsg(msg, len(payload), payload, type=M_TCP)
		
	def sendCommand(self, command):
		"""
		//    uint8:  PlayerID (0..MAX_PLAYERS-1)
		//    uint32: CommandID (see command.h)
		//    uint32: P1 (free variables used in DoCommand)
		//    uint32: P2
		//    uint32: Tile
		//    string: text
		//    uint8:  CallBackID (see callback_table.c)
		"""
		p1 = 0
		p2 = 0
		tile = 2000
		text = "test123"
		cbid=0
		player = self.playas
		payload = packExt('bIIIIzB', player, command, p1, p2, tile, text, cbid)
		payload_size = len(payload)
		self.sendMsg(PACKET_CLIENT_COMMAND, payload_size, payload, type=M_TCP)
		
	def getCompanyString(self, id, withplayers=True):
		if withplayers:
			players = []
			for clientid2 in self.playerlist.keys():
				if self.playerlist[clientid2]['company'] == id:
					players.append(self.playerlist[clientid2]['name'])
		if id == PLAYER_SPECTATOR:
			companystring = "spectators"
		else:
			companystring = "company %d" % (id+1)
		if withplayers:
			if len(players) < 4:
				return "%s (%s)" % (companystring, (", ".join(players)))
			else:
				return "%s (%d players)" % (companystring, len(players))
		else:
			return companystring


	def processCommand(self, event):
		LOG.debug("processing command '%s'" % event.msg)
		if not event.msg.startswith(config.get("main", "commandprefix")):
			return
		command = event.msg[1:]
		if config.has_option('irccommands', command):
			rawcommand = config.get('irccommands', command)
			if not len(rawcommand) > 0:
				return
			interpolation = {
				"frame": self.frame_server,
				"time": time.ctime().__str__(),
				"ip": self.ip,
				"port": self.port,
			}
			proccommand = rawcommand % interpolation
			if len(command) > 0:
				self.processEvent(BotEvent(proccommand, event))
		elif command == "activeplayers":
			#clients = []
			mytime = time.time()
			counter = 0
			for clientid in self.playerlist.keys():
				this_time = mytime - self.playerlist[clientid]['lastactive']
				if this_time < 60*5:
					counter+=1
					compstr = self.getCompanyString(self.playerlist[clientid]['company'])
					timestr = "%d seconds ago" % (this_time)
					self.processEvent(BotEvent("%s last active: %s"%(compstr, playerstr, timestr), event))
				#clients.append[this_time] = self.playerlist[clientid]
			if counter == 0:
				self.processEvent(BotEvent("no companies actively playing in the last 5 minutes", event))
		elif command == 'showplayers':
			for clientid in self.playerlist.keys():
				self.processEvent(BotEvent("Client #%d: %s, playing in %s" % (clientid, self.playerlist[clientid]['name'], self.getCompanyString(self.playerlist[clientid]['company'], False)) event))
		
		# non-useful commands for productive servers,, but the bot may use them itself all the time
		if not config.getboolean("main", "productive") or event.__name__() == 'BotEvent':
			#remove useless commands
			"""
			if command == "test1":
				payload = packExt('bbHz', NETWORK_ACTION_NAME_CHANGE, DESTTYPE_BROADCAST, 0, "foobar")
				payload_size = len(payload)
				self.sendMsg(PACKET_CLIENT_CHAT, payload_size, payload, type=M_TCP)
			elif command == "test2":
				payload = packExt('bbHz', NETWORK_ACTION_GIVE_MONEY, DESTTYPE_BROADCAST, 0, "1783424")
				payload_size = len(payload)
				self.sendMsg(PACKET_CLIENT_CHAT, payload_size, payload, type=M_TCP)
			elif command == "test3":
				payload = packExt('bbHz', NETWORK_ACTION_GIVE_MONEY, DESTTYPE_BROADCAST, 0, "-1783424534")
				payload_size = len(payload)
				self.sendMsg(PACKET_CLIENT_CHAT, payload_size, payload, type=M_TCP)
			elif command == "test4":
				payload = packExt('bbHz', NETWORK_ACTION_SERVER_MESSAGE, DESTTYPE_BROADCAST, 0, "I AM IMPOSING THE SERVER PIEP PIEP")
				payload_size = len(payload)
				self.sendMsg(PACKET_CLIENT_CHAT, payload_size, payload, type=M_TCP)
			elif command == "test5":
				CMD_PLACE_SIGN = 60
				self.sendCommand(CMD_PLACE_SIGN, 0)
			elif command == "test6":
				self.processEvent(BotEvent("Leaving", event))
				self.sendChat("Leaving", type=NETWORK_ACTION_LEAVE)
			elif command == "test7":
				self.sendChat("Joining", type=NETWORK_ACTION_JOIN)
			"""
			if command == 'quit':
				payload = packExt('z', config.get("openttd", "quitmessage"))
				payload_size = len(payload)
				self.sendMsg(PACKET_CLIENT_QUIT, payload_size, payload, type=M_TCP)
			elif command == 'reloadconfig':
				LoadConfig()
				self.processEvent(BotEvent("Reloading config file...", event))
			elif command == 'loadirc' and self.irc is None and config.getboolean("irc", "enable"):
				botnick=(config.get("irc", "nickname"))
				self.irc = IRCBotThread(self.irc_channel, botnick, self.irc_server, self.irc_server_port)
				self.irc.start()
				self.processEvent(BotEvent("loading IRC", event))
			elif command == 'unloadirc' and not self.irc is None:
				self.irc.stop()
				self.irc = None
				self.processEvent(BotEvent("IRC unloaded", event))
			elif command == 'startwebserver':
				self.startWebserver()
			elif command == 'stopwebserver':
				self.stopWebserver()

		# cases not using if/elif
		if command.startswith("lastactive") and len(command) >11:
			arg = command[11:]
			companyid=-1
			if len(arg)<3:
				companyid = int(arg)
			else:
				for clientid in self.playerlist.keys():
					if self.playerlist[clientid]['name'].lower().strip() == arg.lower().strip():
						companyid=self.playerlist[clientid]['company']
			if companyid == -1:
				self.processEvent(BotEvent("company unkown", event))
			else:
				ltime = 0
				for clientid in self.playerlist.keys():
					if self.playerlist[clientid]['company'] == companyid and self.playerlist[clientid]['lastactive'] > ltime:
						ltime = self.playerlist[clientid]['lastactive']
				if ltime <=0:
					timestr = " unkown"
				else:
					timestr = "%d seconds ago" % (time.time()-ltime)
				self.processEvent(BotEvent("company %d last active: %s"%(companyid, timestr), event))
		
	def startWebserver(self):
		if not config.getboolean("webserver", "enable") or not self.webserver is None:
			return
		LOG.debug("starting webserver ...")
		port = config.getint("webserver", "port")
		self.webserver = myWebServer(self, port)
		self.webserver.start()
		self.processEvent(BotEvent("webserver started on port %d"%port))
	
	def stopWebserver(self):
		if self.webserver:
			LOG.debug("stopping webserver ...")
			self.webserver.stop()
			self.webserver = None
			self.processEvent(BotEvent("webserver stopped"))
		
	def handlePacket(self, command, content):
		if command == PACKET_SERVER_QUIT:
			[cid, msg], size = unpackExt('Hz', content)
			if cid == self.client_id:
				self.runCond = False
			if cid in self.playerlist:
				self.processEvent(BotEvent("%s has quit the game (%s)" % (self.playerlist[cid]['name'], msg)))
				del self.playerlist[cid]
		
		elif command == PACKET_SERVER_ERROR:
			[errornum], size = unpackFromExt('B', content, 0)
			if errornum in error_names.keys():
				self.processEvent(BotEvent("Disconnected from server: %s" % error_names[errornum][1]))
			self.runCond = False
		
		elif command == PACKET_SERVER_ERROR_QUIT:
			[cid, errornum], size = unpackExt('HB', content)
			if cid == self.client_id:
				self.doingloop = False
				LOG.info("Disconnected from server")
			if cid in self.playerlist:
				self.processEvent(BotEvent("%s has quit the game (%s)" % (self.playerlist[cid]['name'], error_names[errornum][1])))
				del self.playerlist[cid]

		elif command == PACKET_SERVER_CLIENT_INFO:
			[cid, playas, name], size = unpackExt('HBz', content)
			if cid == self.client_id:
				self.playername = name
				self.playas = playas
			if cid in self.playerlist:
				if name != self.playerlist[cid]['name']:
					self.processEvent(BotEvent("%s has changed his/her nick to %s" % (self.playerlist[cid]['name'], name)))
				if playas != self.playerlist[cid]['company']:
					self.processEvent(BotEvent("%s has been moved to company %d" % (self.playerlist[cid]['name'], playas)))
			self.playerlist[cid] = {'name':name, 'company':playas, 'lastactive':-1}
		
		elif command == PACKET_SERVER_JOIN:
			[playerid], size = unpackFromExt('H', content, 0)
			if playerid in self.playerlist:
				self.processEvent(BotEvent("%s has joined the game" % self.playerlist[playerid]['name']))
		
		if command == PACKET_SERVER_SHUTDOWN:
			self.processEvent(BotEvent("Server shutting down...have a nice day!"))
			self.runCond = False
		
		if command == PACKET_SERVER_NEWGAME:
			self.processEvent(BotEvent("Server loading new map..."))
			# TODO: RECONNECT
			self.runCond = False
	
	def updateStats(self):
		available = True
		try:
			import pickle
		except:
			available=False
		if not available:
			LOG.error("error while loading pickle module, stats saving disabled!")
			return

		LOG.debug("updating stats...")
		value = [self.getGameInfo(), self.getCompanyInfo()]
		
		tstart = time.time()
		fn = config.get("stats", "cachefilename")
		obj=[]
		try:
			f = open(fn, 'rb')
			obj = pickle.load(f)
			f.close()
		except:
			LOG.error("error while opening stats cache file!")
			obj = []
		
		obj.append(value)
		
		try:
			f = open(fn, 'wb')
			#if you use python < 2.3 use this line:
			#pickle.dump(obj, f)
			pickle.dump(obj, f, 1)
			f.close()
		except:
			LOG.error("error while saving stats cache file!")
		
		tdiff = time.time() - tstart
		fs = float(os.path.getsize(fn)) / float(1024)
		LOG.debug("stats updated in %0.5f seconds. File is %.2fKB big (%d lines)"%(tdiff, fs, len(obj)))
	
	def clearStats(self):
		fn = config.get("stats", "cachefilename")
		try:
			os.remove(fn)
			LOG.debug("stats cleared")
		except:
			pass
	
	def joinGame(self):
		#construct join packet
		cversion = self.revision
		self.playername =  config.get("openttd", "nickname")
		password = 'citrus'
		self.playas = PLAYER_SPECTATOR
		language = NETLANG_ANY
		network_id =  config.get("openttd", "uniqueid")
		payload = packExt('zzBBz', cversion, self.playername, self.playas, language, network_id)
		payload_size = len(payload)
		#print "buffer size: %d" % payload_size
		self.sendMsg(PACKET_CLIENT_JOIN, payload_size, payload, type=M_TCP)
		self.runCond=True
		while self.runCond:
			size, command, content = self.receiveMsg_TCP()
			LOG.debug("got command %s" % packet_names[command])
			if command == PACKET_SERVER_FULL:
				LOG.info("Couldn't join server...it's full. Exiting!")
				self.runCond=False
			if command == PACKET_SERVER_BANNED:
				LOG.info("Couldn't join server...banned from it. Exiting!")
				self.runCond=False
			if command == PACKET_SERVER_CHECK_NEWGRFS:
				offset = 0
				[grfcount], size = unpackFromExt('B', content, offset)
				offset += size
				grfs = []
				if grfcount != 0:
					for i in range(0, grfcount):
						[grfid, md5sum], size = unpackFromExt('4s16s', content[offset:])
						offset += size
						grfs.append((grfid, md5sum))
					LOG.debug("installed grfs (%d):" % len(grfs))
					for grf in grfs:
						LOG.debug(" %s - %s" % (grf[0].encode("hex"), grf[1].__str__().encode("hex")))
				LOG.debug("step2 - got installed GRFs, joining ...")
				self.sendMsg(PACKET_CLIENT_NEWGRFS_CHECKED, type=M_TCP)
				
			elif command == PACKET_SERVER_NEED_PASSWORD:
				[type,seed,uniqueid], size = unpackExt('BIz', content)
				if type == NETWORK_GAME_PASSWORD:
					if self.password != '':
						LOG.info("server is password protected, sending password ...")
						payload = packExt('Bz', NETWORK_GAME_PASSWORD, self.password)
						payload_size = len(payload)
						self.sendMsg(PACKET_CLIENT_PASSWORD, payload_size, payload, type=M_TCP)
					else:
						LOG.info("server is password protected, but no pass provided, exiting!")
						self.runCond=False
				elif type == NETWORK_COMPANY_PASSWORD:
					#if self.password != '':
					#salted_password=""*32
					#password="apassword"
					#for i in range(1,32):
					#	salted_password[i] = int(password[i]) ^ uniqueid[i] ^ (seed >> i)
					#	LOG.info(i)
					#LOG.info(salted_password)
					#else:
					LOG.info("company is password protected, not supported, exiting!")
					self.runCond=False

				
			elif command == PACKET_SERVER_WELCOME:
				LOG.info("yay, we are on the server :D (getting the map now ...)")
				
				[self.client_id, self.generation_seed, self.servernetworkid], size = unpackExt('HIz', content)
				
				self.socket_tcp.settimeout(600000000)
				
				downloadDone = False
				self.sendMsg(PACKET_CLIENT_GETMAP, type=M_TCP)
				mapsize_done = 0
				while not downloadDone and self.runCond:
					size, command, content = self.receiveMsg_TCP()
					
					# first check if it is a command we need to run
					self.handlePacket(command, content)
					
					if command == PACKET_SERVER_WAIT:
						[num], res = unpackFromExt('B', content)
						self.processEvent(BotEvent("Waiting for map download...%d in line" % num))
					
					if command == PACKET_SERVER_MAP:
						offset = 0
						[command2], size2 = unpackFromExt('B', content[offset:])
						offset += size2
						
						if command2 == MAP_PACKET_START:
							LOG.info("starting downloading map!")
							[framecounter], size2 = unpackFromExt('I', content[offset:])
							offset += size2
							
							[position], size2 = unpackFromExt('I', content[offset:])
							offset += size2
						elif command2 == MAP_PACKET_NORMAL:
							mapsize_done += size
							if int(mapsize_done / 1024) % 100 == 0:
								LOG.debug("got %d kB ..." % (mapsize_done / 1024))
						elif command2 == MAP_PACKET_END:
							LOG.info("done downloading map!")
							downloadDone=True
				
				self.sendMsg(PACKET_CLIENT_MAP_OK, type=M_TCP)
				
				# main loop, disable the timeout
				#self.socket_tcp.settimeout(600000000)
				frameCounter=73
				self.frame_server=0
				self.frame_max=0
				
				# init IRC bridge
				self.irc = None
				
				#self.processEvent(BotEvent("hey i am a bot :|"))
				
				# auto start IRC
				if config.getboolean("irc", "autojoin"):
					self.processEvent(BotEvent(config.get("main", "commandprefix") + "loadirc"))
				if config.getboolean("webserver", "autostart"):
					self.startWebserver()
				
				
				
				ignoremsgs = []
				companyrefresh_interval = 120 #every two minutes
				companyrefresh_last = 0
				
				doStats = config.getboolean("stats", "enable")
				if doStats:
					self.clearStats()
				
				while self.runCond:
					size, command, content = self.receiveMsg_TCP()
					#print content
					self.handlePacket(command, content)
					if command == PACKET_SERVER_FRAME:
						old_framecounter = self.frame_server
						[self.frame_server, self.frame_max], size = unpackFromExt('II', content)
						#if self.debug:
						#	print "got frame %d, %d" % (frame_server, frame_max)
						frameCounter += (self.frame_server - old_framecounter)
						
					if frameCounter >= 74:
						payload = packExt('I', self.frame_server)
						payload_size = len(payload)
						#print "sending ACK"
						self.sendMsg(PACKET_CLIENT_ACK, payload_size, payload, type=M_TCP)
						frameCounter=0
					
					if doStats and time.time() - companyrefresh_last > companyrefresh_interval:
						self.updateStats()
						companyrefresh_last = time.time()
						
					if command == PACKET_SERVER_COMMAND:
						[player, command2, p1, p2, tile, text, callback, frame, my_cmd], size = unpackFromExt('BIIIIzBIB', content)

						commandid = command2 & 0xff
						#print commandid
						if commandid in command_names.keys():
							LOG.debug("got command: %d(%s) from company %d: '%s'" % (commandid, command_names[commandid].__str__(), player, text))

						#print player, command2, p1, p2, tile, text, callback, frame, my_cmd
	
						# some example  implementation
						companystr = self.getCompanyString(player)
						if commandid == 61: #CMD_RENAME_SIGN
							if text != '':
								self.processEvent(BotEvent("%s renames a sign: '%s'" % (companystr, text)))
						elif commandid == 46: #CMD_SET_PLAYER_COLOR
							self.processEvent(BotEvent("%s changed their color"%companystr))
						elif commandid == 52: #CMD_CHANGE_COMPANY_NAME
							self.processEvent(BotEvent("%s changed their company name to '%s'"%(companystr, text)))
						elif commandid == 53: #CMD_CHANGE_PRESIDENT_NAME
							self.processEvent(BotEvent("%s changed their presidents name to '%s'"%(companystr, text)))
						elif commandid == 43: #CMD_BUILD_INDUSTRY
							self.processEvent(BotEvent("%s built a new industry"%(companystr)))
						elif commandid == 44: #CMD_BUILD_COMPANY_HQ
							self.processEvent(BotEvent("%s built their new HQ"%(companystr)))
							
	
					if command == PACKET_SERVER_CHAT:
						[actionid, playerid, unused, msg], size = unpackExt('bHbz', content)
						self_sent = (playerid == self.client_id)
						if playerid in self.playerlist:
							player_name = self.playerlist[playerid]['name']
							
							broadcast = 0
							msgtxt = msg
							if actionid == NETWORK_ACTION_CHAT:
								if self_sent:
									msgtxt = msg
								else:
									msgtxt = "%s: %s" % (player_name, msg)
							elif actionid == NETWORK_ACTION_CHAT_COMPANY:
								msgtxt = "[Team] %s: %s" % (player_name, msg)
								broadcast=1
							elif actionid == NETWORK_ACTION_CHAT_CLIENT:
								msgtxt = "[IRC_ONLY] %s: %s" % (player_name, msg)
							else:
								msg = ""
							
							gce = GameChatEvent(msg, msgtxt, playerid, player_name, None, self_sent)
							self.processEvent(gce)
						#LOG.debug(res.__str__())
						
					if not self.irc is None:
						#check if there are msgs in the IRC to say
						for msg in self.irc.getSaid():
							txt_res = ''
							nickname, msgtxt, type = msg
							if type == 'pubmsg':
								#normal chat
								txt_res = "%s: %s" % (nickname, msgtxt)
							elif type == 'action':
								# action
								txt_res = "%s %s" % (nickname, msgtxt)
							elif type == 'internal':
								# action
								txt_res = "%s" % (msgtxt)
							
							# do not process stuff we said by ourself
							if nickname != config.get("irc", "nickname"):
								self.processEvent(IRCChatEvent(msgtxt, nickname, type))


def printUsage():
	print "usage: %s <ip:port> <password>" % sys.argv[0]
	sys.exit(1)

def main():
	# catch errors when we don't supply enough parameters  
	password = ''
	if len(sys.argv) == 0:
		printUsage()
	
	try:
		ip, port = sys.argv[1].split(':')
		port = int(port)
		if len(sys.argv) > 2:
			password = sys.argv[2]
	except Exception, e:
		#LOG.error(e)
		printUsage()

	client = SpectatorClient(ip, port, True)
	client.connect(M_BOTH)
	gameinfo = client.getGameInfo()
	client.revision = gameinfo.server_revision
	client.password = password
	client.joinGame()
	client.disconnect()
	sys.exit(0)

if __name__ == '__main__':
	main()
